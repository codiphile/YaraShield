import yara
import os
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import threading
import time
from datetime import datetime
import webbrowser

class MalwareScannerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("YaraShield - Advanced Malware Detector")
        self.root.geometry("900x600")
        self.root.minsize(800, 550)
        
        # Set theme and styles
        self.setup_styles()
        
        # Initialize variables
        self.rules = None
        self.scan_in_progress = False
        self.last_scan_time = 0
        self.rules_last_compiled = 0
        self.selected_rules = {}
        
        # Create status_var BEFORE compiling rules
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")
        
        # Load YARA rules
        self.rules = self.compile_rules()
        
        # Create GUI components
        self.create_widgets()
        
        # Status bar
        self.status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Check for updates to rule files
        self.setup_rule_file_monitoring()
    
    def setup_styles(self):
        """Set up custom styles for the application"""
        self.style = ttk.Style()
        
        # Configure colors and styles
        self.style.configure("TFrame", background="#f5f5f5")
        self.style.configure("TLabel", background="#f5f5f5", font=("Helvetica", 10))
        self.style.configure("TButton", font=("Helvetica", 10))
        self.style.configure("Header.TLabel", font=("Helvetica", 14, "bold"))
        self.style.configure("Scan.TButton", font=("Helvetica", 12, "bold"))
        self.style.configure("Title.TLabel", font=("Helvetica", 16, "bold"))
        
        # Configure notebook style
        self.style.configure("TNotebook", background="#f5f5f5", tabposition="n")
        self.style.configure("TNotebook.Tab", font=("Helvetica", 11))
    
    def create_widgets(self):
        """Create all GUI widgets"""
        # Main container
        self.main_frame = ttk.Frame(self.root, padding="10")
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Header with logo (text-based for now)
        self.header_frame = ttk.Frame(self.main_frame)
        self.header_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.title_label = ttk.Label(self.header_frame, text="YaraShield", style="Title.TLabel")
        self.title_label.pack(side=tk.LEFT)
        
        # About button
        self.about_btn = ttk.Button(self.header_frame, text="About", command=self.show_about)
        self.about_btn.pack(side=tk.RIGHT)
        
        # Help button
        self.help_btn = ttk.Button(self.header_frame, text="Help", command=self.show_help)
        self.help_btn.pack(side=tk.RIGHT, padx=5)
        
        # Create notebook (tabbed interface)
        self.notebook = ttk.Notebook(self.main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Scanner tab
        self.scanner_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.scanner_frame, text="File Scanner")
        
        # Rules tab
        self.rules_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.rules_frame, text="YARA Rules")
        
        # Setup scanner tab UI
        self.setup_scanner_tab()
        
        # Setup rules tab UI
        self.setup_rules_tab()
    
    def setup_scanner_tab(self):
        """Set up the scanner tab interface"""
        # File Selection
        self.file_frame = ttk.LabelFrame(self.scanner_frame, text="File Selection", padding="10")
        self.file_frame.pack(fill=tk.X)
        
        self.file_label = ttk.Label(self.file_frame, text="File to Scan:")
        self.file_label.grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        
        self.file_entry = ttk.Entry(self.file_frame, width=50)
        self.file_entry.grid(row=0, column=1, sticky=tk.EW, padx=5, pady=5)
        
        self.browse_btn = ttk.Button(self.file_frame, text="Browse", command=self.browse_file)
        self.browse_btn.grid(row=0, column=2, padx=5, pady=5)
        
        # Allow the middle column to expand
        self.file_frame.columnconfigure(1, weight=1)
        
        # Scan Button with loading indicator
        self.scan_frame = ttk.Frame(self.scanner_frame)
        self.scan_frame.pack(pady=10)
        
        self.scan_btn = ttk.Button(self.scan_frame, text="Scan File", 
                                  command=self.start_scan_thread, style="Scan.TButton")
        self.scan_btn.pack(side=tk.LEFT, padx=10)
        
        self.progress_var = tk.DoubleVar()
        self.progress = ttk.Progressbar(self.scan_frame, variable=self.progress_var, 
                                        mode="indeterminate", length=200)
        self.progress.pack(side=tk.LEFT, padx=10)
        
        # Results Display
        self.results_frame = ttk.LabelFrame(self.scanner_frame, text="Scan Results", padding="10")
        self.results_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        self.results_text = tk.Text(self.results_frame, height=15, wrap=tk.WORD)
        self.results_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.scrollbar = ttk.Scrollbar(self.results_frame, orient=tk.VERTICAL, command=self.results_text.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_text.configure(yscrollcommand=self.scrollbar.set)
        
        # Configure tag for colorizing text
        self.results_text.tag_configure("header", font=("Helvetica", 12, "bold"))
        self.results_text.tag_configure("alert", foreground="red", font=("Helvetica", 11, "bold"))
        self.results_text.tag_configure("safe", foreground="green", font=("Helvetica", 11, "bold"))
        self.results_text.tag_configure("info", foreground="blue")
    
    def setup_rules_tab(self):
        """Set up the rules management tab"""
        # Rules info
        info_frame = ttk.Frame(self.rules_frame)
        info_frame.pack(fill=tk.X, pady=5)
        
        rule_info_label = ttk.Label(info_frame, 
                                   text="Manage YARA rules for malware detection", 
                                   style="Header.TLabel")
        rule_info_label.pack(anchor=tk.W)
        
        # Create a split pane for rule management
        rules_pane = ttk.PanedWindow(self.rules_frame, orient=tk.HORIZONTAL)
        rules_pane.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Left side - Available Rules
        rule_list_frame = ttk.LabelFrame(rules_pane, text="Available Rule Files", padding="10")
        
        # Rule file management buttons
        rule_buttons_frame = ttk.Frame(rule_list_frame)
        rule_buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.create_rule_btn = ttk.Button(rule_buttons_frame, text="New Rule", command=self.create_new_rule)
        self.create_rule_btn.pack(side=tk.LEFT, padx=5)
        
        self.delete_rule_btn = ttk.Button(rule_buttons_frame, text="Delete Rule", command=self.delete_rule)
        self.delete_rule_btn.pack(side=tk.LEFT, padx=5)
        
        self.reload_rules_btn = ttk.Button(rule_buttons_frame, text="Reload Rules", command=self.reload_rules)
        self.reload_rules_btn.pack(side=tk.RIGHT, padx=5)
        
        # Rules listbox with scrollbar
        rules_list_frame = ttk.Frame(rule_list_frame)
        rules_list_frame.pack(fill=tk.BOTH, expand=True)
        
        self.rules_listbox = tk.Listbox(rules_list_frame, height=10, selectmode=tk.SINGLE)
        self.rules_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        rules_scrollbar = ttk.Scrollbar(rules_list_frame, orient=tk.VERTICAL, command=self.rules_listbox.yview)
        rules_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.rules_listbox.configure(yscrollcommand=rules_scrollbar.set)
        
        # Bind selection event
        self.rules_listbox.bind('<<ListboxSelect>>', self.on_rule_selected)
        
        # Add rule list frame to paned window
        rules_pane.add(rule_list_frame, weight=1)
        
        # Right side - Rule Editor
        rule_editor_frame = ttk.LabelFrame(rules_pane, text="Rule Editor", padding="10")
        
        # Editor buttons
        editor_buttons_frame = ttk.Frame(rule_editor_frame)
        editor_buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.save_rule_btn = ttk.Button(editor_buttons_frame, text="Save Changes", command=self.save_rule_changes)
        self.save_rule_btn.pack(side=tk.LEFT, padx=5)
        self.save_rule_btn.config(state=tk.DISABLED)  # Disabled until a rule is selected
        
        # Rule editor with line numbers
        editor_frame = ttk.Frame(rule_editor_frame)
        editor_frame.pack(fill=tk.BOTH, expand=True)
        
        # Rule details text editor
        self.rule_editor = tk.Text(editor_frame, height=20, wrap=tk.NONE, undo=True)
        self.rule_editor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Add horizontal scrollbar
        h_scrollbar = ttk.Scrollbar(rule_editor_frame, orient=tk.HORIZONTAL, command=self.rule_editor.xview)
        h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Add vertical scrollbar
        v_scrollbar = ttk.Scrollbar(editor_frame, orient=tk.VERTICAL, command=self.rule_editor.yview)
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Configure scrollbars
        self.rule_editor.configure(xscrollcommand=h_scrollbar.set, yscrollcommand=v_scrollbar.set)
        
        # Add syntax highlighting tags
        self.setup_editor_highlighting()
        
        # Bind text modifications to enable save button
        self.rule_editor.bind("<<Modified>>", self.on_rule_modified)
        
        # Add rule editor frame to paned window
        rules_pane.add(rule_editor_frame, weight=2)
        
        # Populate rule files list
        self.refresh_rule_files_list()
    
    def setup_editor_highlighting(self):
        """Set up syntax highlighting for the YARA rule editor"""
        # Configure tags for syntax highlighting
        self.rule_editor.tag_configure("keyword", foreground="#0033CC", font=("Courier", 10, "bold"))
        self.rule_editor.tag_configure("string", foreground="#009900")
        self.rule_editor.tag_configure("comment", foreground="#999999", font=("Courier", 10, "italic"))
        self.rule_editor.tag_configure("meta", foreground="#CC6600")
        self.rule_editor.tag_configure("condition", foreground="#990099", font=("Courier", 10, "bold"))
        
        # Set monospace font for code
        self.rule_editor.configure(font=("Courier", 10))
    
    def apply_syntax_highlighting(self):
        """Apply syntax highlighting to the rule editor content with safer implementation"""
        try:
            # This is a safer implementation that avoids some of the macOS text widget issues
            
            # Reset all tags first
            for tag in ["keyword", "string", "comment", "meta", "condition"]:
                self.rule_editor.tag_remove(tag, "1.0", tk.END)
            
            # Get all text content at once to avoid repeated access
            content = self.rule_editor.get("1.0", tk.END)
            content_lines = content.split('\n')
            
            # Process line by line instead of using regex search across the entire text
            for line_num, line in enumerate(content_lines, 1):
                # Process comments (safest to do first as they take precedence)
                comment_idx = line.find('//')
                if comment_idx >= 0:
                    start_idx = f"{line_num}.{comment_idx}"
                    end_idx = f"{line_num}.end"
                    self.rule_editor.tag_add("comment", start_idx, end_idx)
                    # Skip further processing for commented parts
                    line = line[:comment_idx]
                
                # Process keywords
                keywords = ["rule", "meta", "strings", "condition", "private", "global"]
                for keyword in keywords:
                    start_idx = 0
                    while True:
                        idx = line.find(keyword, start_idx)
                        if idx == -1:
                            break
                        
                        # Check if it's a whole word (not part of another word)
                        is_whole_word = True
                        if idx > 0 and (line[idx-1].isalnum() or line[idx-1] == '_'):
                            is_whole_word = False
                        end_pos = idx + len(keyword)
                        if end_pos < len(line) and (line[end_pos].isalnum() or line[end_pos] == '_'):
                            is_whole_word = False
                        
                        if is_whole_word:
                            start_pos = f"{line_num}.{idx}"
                            end_pos = f"{line_num}.{idx + len(keyword)}"
                            self.rule_editor.tag_add("keyword", start_pos, end_pos)
                        
                        start_idx = idx + len(keyword)
                
                # Process strings (safer implementation without complex regex)
                if '$' in line and '=' in line and '"' in line:
                    # Simple check for string definitions
                    var_idx = line.find('$')
                    equals_idx = line.find('=', var_idx)
                    quote_idx = line.find('"', equals_idx)
                    
                    if var_idx >= 0 and equals_idx > var_idx and quote_idx > equals_idx:
                        # Find closing quote if it exists
                        end_quote_idx = line.find('"', quote_idx + 1)
                        if end_quote_idx > quote_idx:
                            start_pos = f"{line_num}.{var_idx}"
                            end_pos = f"{line_num}.{end_quote_idx + 1}"
                            self.rule_editor.tag_add("string", start_pos, end_pos)
        
        except Exception as e:
            # Silently handle errors to prevent application crashes
            print(f"Syntax highlighting error: {str(e)}")
            pass
    
    def create_new_rule(self):
        """Create a new YARA rule file"""
        # Ask for rule file name
        rule_name = simpledialog.askstring("New Rule File", "Enter name for new rule file (without .yar extension):")
        if not rule_name:
            return
        
        # Make sure name is valid
        if not rule_name.isalnum() and not '_' in rule_name:
            messagebox.showerror("Invalid Name", "Rule file name must contain only letters, numbers, and underscores.")
            return
        
        # Add .yar extension if not present
        if not rule_name.endswith('.yar'):
            rule_name = rule_name + '.yar'
        
        # Check if file already exists
        rule_path = os.path.join("rules", rule_name)
        if os.path.exists(rule_path):
            messagebox.showerror("File Exists", f"A rule file named '{rule_name}' already exists.")
            return
        
        # Create template for new rule
        current_date = datetime.now().strftime("%Y-%m-%d")
        template = f'''// {rule_name} - Created {current_date}
rule New_Rule {{
    meta:
        name = "New Rule"
        description = "Description of what this rule detects"
        author = "Your Name"
        date = "{current_date}"
        severity = "Medium"
    
    strings:
        $string1 = "suspicious_string1" nocase
        $string2 = "suspicious_string2" nocase
    
    condition:
        any of them
}}
'''
        
        # Write new rule file
        try:
            with open(rule_path, 'w') as file:
                file.write(template)
            
            # Refresh rule list and select new rule
            self.refresh_rule_files_list()
            self.rules_listbox.selection_clear(0, tk.END)
            
            # Find the new rule in the list and select it
            items = self.rules_listbox.get(0, tk.END)
            for i, item in enumerate(items):
                if item == rule_name:
                    self.rules_listbox.selection_set(i)
                    self.rules_listbox.see(i)
                    self.on_rule_selected(None)
                    break
            
            messagebox.showinfo("Rule Created", f"New rule file '{rule_name}' has been created.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to create rule file: {str(e)}")
    
    def delete_rule(self):
        """Delete the selected YARA rule file"""
        selection = self.rules_listbox.curselection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a rule file to delete.")
            return
        
        selected_rule = self.rules_listbox.get(selection[0])
        
        # Confirm deletion
        if not messagebox.askyesno("Confirm Delete", 
                                  f"Are you sure you want to delete the rule file '{selected_rule}'?\n\nThis cannot be undone!"):
            return
        
        # Delete the file
        rule_path = os.path.join("rules", selected_rule)
        try:
            os.remove(rule_path)
            self.refresh_rule_files_list()
            self.rule_editor.delete(1.0, tk.END)  # Clear the editor
            self.save_rule_btn.config(state=tk.DISABLED)
            messagebox.showinfo("Rule Deleted", f"Rule file '{selected_rule}' has been deleted.")
            
            # Reload rules
            self.reload_rules()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to delete rule file: {str(e)}")
    
    def on_rule_selected(self, event):
        """Display selected rule file contents in the editor"""
        selection = self.rules_listbox.curselection()
        if not selection:
            return
        
        selected_rule = self.rules_listbox.get(selection[0])
        rule_path = os.path.join("rules", selected_rule)
        
        try:
            # Clear any previous content first
            self.rule_editor.delete("1.0", tk.END)
            
            # Read the file content
            with open(rule_path, 'r') as file:
                content = file.read()
            
            # Insert content in a safer way
            if content:
                self.rule_editor.insert("1.0", content)
                
                # Apply syntax highlighting in a try-except block to prevent crashes
                try:
                    self.apply_syntax_highlighting()
                except Exception as e:
                    print(f"Highlighting error: {str(e)}")
                    # Continue even if highlighting fails
                    pass
            
            # Reset modified flag after a short delay to avoid widget issues
            self.root.after(100, lambda: self.rule_editor.edit_modified(False))
            
            # Disable save button initially
            self.save_rule_btn.config(state=tk.DISABLED)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read rule file: {str(e)}")
    
    def on_rule_modified(self, event):
        """Handle modifications to the rule text"""
        try:
            if self.rule_editor.edit_modified():
                self.save_rule_btn.config(state=tk.NORMAL)
                # Reset the modified flag to catch the next change
                self.rule_editor.edit_modified(False)
        except Exception as e:
            # Silently handle any widget errors
            print(f"Text modification error: {str(e)}")
            pass
    
    def save_rule_changes(self):
        """Save changes to the selected rule file"""
        selection = self.rules_listbox.curselection()
        if not selection:
            return
        
        selected_rule = self.rules_listbox.get(selection[0])
        rule_path = os.path.join("rules", selected_rule)
        
        # Get content from editor
        content = self.rule_editor.get(1.0, tk.END)
        
        # Try to validate the YARA rule syntax (basic validation)
        if "rule " not in content or "condition:" not in content:
            if not messagebox.askyesno("Invalid Rule", 
                                      "The rule doesn't appear to have a valid YARA syntax.\n\nSave anyway?"):
                return
        
        # Save the file
        try:
            with open(rule_path, 'w') as file:
                file.write(content)
            
            self.save_rule_btn.config(state=tk.DISABLED)
            messagebox.showinfo("Rule Saved", f"Changes to '{selected_rule}' have been saved.")
            
            # Reload rules
            self.reload_rules()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save rule file: {str(e)}")
    
    def reload_rules(self):
        """Reload YARA rules from rule files"""
        previous_rules = self.rules
        self.rules = self.compile_rules()
        
        if self.rules:
            self.status_var.set("Rules reloaded successfully")
            self.rules_last_compiled = time.time()
            self.refresh_rule_files_list()
            return True
        else:
            # If compilation fails, restore previous rules
            self.rules = previous_rules
            self.status_var.set("Failed to reload rules - reverted to previous ruleset")
            return False
    
    def refresh_rule_files_list(self):
        """Update the list of available rule files"""
        self.rules_listbox.delete(0, tk.END)
        
        try:
            for f in os.listdir("rules"):
                if f.endswith(".yar"):
                    self.rules_listbox.insert(tk.END, f)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to list rule files: {str(e)}")
    
    def setup_rule_file_monitoring(self):
        """Set up periodic check for rule file modifications"""
        self.check_rule_files()
        # Check less frequently (every 30 seconds instead of 10)
        self.root.after(30000, self.setup_rule_file_monitoring)
    
    def check_rule_files(self):
        """Check if any rule files have been modified since last compilation"""
        try:
            # Only check if we haven't checked in the last 60 seconds
            if time.time() - self.last_scan_time < 60:
                return
            
            latest_mod_time = 0
            for f in os.listdir("rules"):
                if f.endswith(".yar"):
                    file_path = os.path.join("rules", f)
                    mod_time = os.path.getmtime(file_path)
                    if mod_time > latest_mod_time:
                        latest_mod_time = mod_time
            
            # Only prompt if rules have been modified and compilation was successful previously
            if latest_mod_time > self.rules_last_compiled and self.rules is not None:
                # Use a status message instead of a dialog for less interruption
                self.status_var.set("YARA rules have been modified. Click 'Reload Rules' to update.")
        except Exception as e:
            self.status_var.set(f"Error checking rule files: {str(e)}")
    
    def compile_rules(self):
        """Compile all YARA rule files"""
        try:
            rule_files = {}
            for f in os.listdir("rules"):
                if f.endswith(".yar"):
                    rule_path = os.path.join("rules", f)
                    # Verify each rule file individually first
                    try:
                        yara.compile(filepath=rule_path)
                        rule_files[f] = rule_path
                    except yara.SyntaxError as e:
                        messagebox.showerror("Rule Syntax Error", 
                                            f"Error in file '{f}':\n{str(e)}\n\nThis rule file will be skipped.")
                        continue
                    except Exception as e:
                        messagebox.showerror("Rule Error", 
                                            f"Error compiling '{f}':\n{str(e)}\n\nThis rule file will be skipped.")
                        continue
            
            if not rule_files:
                messagebox.showerror("Error", "No valid YARA rules found in rules directory!")
                return None
            
            # Compile all valid rules together
            compiled_rules = yara.compile(filepaths=rule_files)
            self.rules_last_compiled = time.time()
            self.status_var.set(f"Rules compiled successfully: {len(rule_files)} files")
            return compiled_rules
        except yara.SyntaxError as e:
            messagebox.showerror("Rule Error", f"YARA syntax error: {str(e)}")
            return None
        except Exception as e:
            messagebox.showerror("Error", f"Failed to compile rules: {str(e)}")
            return None
    
    def browse_file(self):
        """Open file browser to select a file"""
        file_path = filedialog.askopenfilename()
        if file_path:
            self.file_entry.delete(0, tk.END)
            self.file_entry.insert(0, file_path)
    
    def start_scan_thread(self):
        """Start file scanning in a separate thread"""
        if self.scan_in_progress:
            messagebox.showinfo("Scan in Progress", "A scan is already running. Please wait.")
            return
            
        file_path = self.file_entry.get()
        if not file_path or not os.path.isfile(file_path):
            messagebox.showwarning("Input Error", "Please select a valid file!")
            return
        
        # Start progress bar
        self.scan_in_progress = True
        self.progress.start()
        self.scan_btn.config(state=tk.DISABLED)
        
        # Clear previous results
        self.results_text.delete(1.0, tk.END)
        self.status_var.set(f"Scanning file: {os.path.basename(file_path)}")
        
        # Start scanning in a thread
        scan_thread = threading.Thread(target=self.scan_file, args=(file_path,))
        scan_thread.daemon = True
        scan_thread.start()
    
    def scan_file(self, file_path):
        """Scan a file for malware using YARA rules"""
        try:
            # Record start time
            start_time = time.time()
            
            # Display scan info
            scan_info = f"Scanning: {file_path}\n"
            scan_info += f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            scan_info += f"File Size: {os.path.getsize(file_path):,} bytes\n"
            scan_info += "=" * 50 + "\n\n"
            
            self.results_text.insert(tk.END, scan_info, "info")
            
            # Perform scan
            matches = self.rules.match(file_path)
            
            # Calculate scan time
            scan_time = time.time() - start_time
            
            # Report results
            if matches:
                self.results_text.insert(tk.END, "ðŸš¨ MALWARE DETECTED!\n\n", "alert")
                
                for match in matches:
                    malware_name = match.meta.get('name', 'Unknown Malware')
                    description = match.meta.get('description', 'No description available')
                    severity = match.meta.get('severity', 'Unknown')
                    
                    match_info = f"â€¢ Detection Name: {malware_name}\n"
                    match_info += f"  Rule: {match.rule}\n"
                    match_info += f"  Severity: {severity}\n"
                    match_info += f"  Description: {description}\n\n"
                    
                    self.results_text.insert(tk.END, match_info)
                
                self.status_var.set(f"Alert: Malware detected! ({len(matches)} matches)")
            else:
                self.results_text.insert(tk.END, "âœ… FILE IS CLEAN\n", "safe")
                self.results_text.insert(tk.END, "No threats detected\n\n")
                self.status_var.set("Scan complete: No threats detected")
            
            # Display scan time
            self.results_text.insert(tk.END, f"\nScan completed in {scan_time:.2f} seconds\n")
            
        except Exception as e:
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, f"Error scanning file: {str(e)}", "alert")
            self.status_var.set(f"Error: {str(e)}")
        finally:
            # Stop progress bar
            self.progress.stop()
            self.scan_btn.config(state=tk.NORMAL)
            self.scan_in_progress = False
            self.last_scan_time = time.time()
    
    def show_about(self):
        """Show about dialog"""
        about_text = (
            "YaraShield - Advanced Malware Detection Tool\n\n"
            "Version: 1.0.0\n"
            "Author: Mudit Sharma\n\n"
            "This tool uses YARA rules to detect various types of malware "
            "in files, helping to identify threats and secure your system."
        )
        messagebox.showinfo("About YaraShield", about_text)
    
    def show_help(self):
        """Show help information"""
        help_text = (
            "How to use YaraShield:\n\n"
            "1. Select a file to scan using the 'Browse' button\n"
            "2. Click 'Scan File' to analyze the file for malware\n"
            "3. View results in the text area below\n\n"
            "You can manage YARA rules in the 'YARA Rules' tab."
        )
        messagebox.showinfo("YaraShield Help", help_text)

def main():
    root = tk.Tk()
    app = MalwareScannerGUI(root)
    
    # Set window icon (text-based for now)
    root.iconbitmap(default=None)
    
    # Center window on screen
    window_width = 900
    window_height = 600
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    x = (screen_width - window_width) // 2
    y = (screen_height - window_height) // 2
    root.geometry(f"{window_width}x{window_height}+{x}+{y}")
    
    root.mainloop()

if __name__ == "__main__":
    main()